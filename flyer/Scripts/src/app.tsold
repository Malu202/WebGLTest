module ilands {

    interface IMover {
        moveWithCollisions(mesh: BABYLON.AbstractMesh, direction: BABYLON.Vector3);
    }

    class Mover implements IMover {
        constructor(private grounds: BABYLON.AbstractMesh[], private collisions: BABYLON.AbstractMesh[]) { }
        private checkOnGround(desiredPoint: BABYLON.Vector3): BABYLON.Vector3 {
            var intersection: BABYLON.PickingInfo;
            var downRay = new BABYLON.Ray(desiredPoint, new BABYLON.Vector3(0, -1, 0));
            var upRay;
            for (var i = 0; i < this.grounds.length; i++) {
                intersection = this.grounds[i].intersects(downRay);
                if (!intersection.hit) {
                    upRay = upRay || new BABYLON.Ray(desiredPoint, new BABYLON.Vector3(0, 1, 0));
                    intersection = this.grounds[i].intersects(upRay);
                }
                if (intersection.hit) {
                    break;
                }
            }
            if (intersection.hit) {
                return intersection.pickedPoint;
            }
            return null;
        }

        moveWithCollisions(mesh: BABYLON.AbstractMesh, direction: BABYLON.Vector3) {
            var desiredPoint = mesh.position.add(direction);
            var groundPosition = this.checkOnGround(desiredPoint);
            if (groundPosition) {
                //if (Math.abs(Math.asin(BABYLON.Vector3.Dot(mesh.position.subtract(groundPosition).normalize(), new Vector3(0, 1, 0)))) < Math.PI / 6) {
                var before = mesh.position;
                mesh.position = groundPosition;
                for (var i = 0; i < this.collisions.length; i++) {
                    var collider = this.collisions[i];
                    var colliderPos = collider.absolutePosition;
                    if (collider.intersectsMesh(mesh, false) && !(before.subtract(colliderPos).length() <= mesh.position.subtract(colliderPos).length())) {
                        mesh.position = before;
                        break;
                    }
                }
                //}
            }
        }
    }

   

    var ilands = function () {

        
        waterMaterial.reflectionTexture.renderList.push(skybox);

        var collisions = new Array<BABYLON.AbstractMesh>();

        BABYLON.SceneLoader.ImportMesh(null, "Assets/blender/", "urcark_seperated.babylon", scene, (meshes, p, s) => {
            //waterMaterial.reflectionTexture.renderList.push(meshes[0]);
            waterMaterial.reflectionTexture.renderList.push(meshes[1]);
            //waterMaterial.refractionTexture.renderList.push(meshes[0]);
            waterMaterial.refractionTexture.renderList.push(meshes[1]);
            var player = new Player(scene, "Player", camera, new KeyStateService(), new Mover([meshes[1]], collisions));
        });

        interface Position {
            x?: number;
            y?: number;
            z?: number;
            yaw?: number;
        }

        interface OtherPlayer {
            mesh?: BABYLON.AbstractMesh;
            pos?: Position;
            animation?: BABYLON.Animatable
        }

        var clients = {};

        var other_turnspeed = 0.05;
        var other_speed = 0.2;

        (<any>window).setPlayerPosition = function (clientId: string, position: Position) {
            if (!clients[clientId]) {
                var otherPlayer: OtherPlayer = { pos: position };
                clients[clientId] = otherPlayer;
                BABYLON.SceneLoader.ImportMesh("Player", "Assets/blender/", "player.babylon", scene, (meshes, p, s) => {
                    otherPlayer.mesh = meshes[0];
                    scene.registerBeforeRender(function () {
                        
                        if ((otherPlayer.mesh.rotation.y - otherPlayer.pos.yaw) > other_turnspeed) {
                            otherPlayer.mesh.rotation.y -= other_turnspeed;
                        } else if ((otherPlayer.mesh.rotation.y - otherPlayer.pos.yaw) < other_turnspeed) {
                            otherPlayer.mesh.rotation.y += other_turnspeed;
                        }
                        var forward = new BABYLON.Vector3(-Math.sin(otherPlayer.mesh.rotation.y), 0, -Math.cos(otherPlayer.mesh.rotation.y)).normalize();
                        var distance = new BABYLON.Vector3(otherPlayer.pos.x, otherPlayer.pos.y, otherPlayer.pos.z).subtract(otherPlayer.mesh.position);
                        if (distance.length() > other_speed) {
                            otherPlayer.mesh.position = otherPlayer.mesh.position.add(distance.normalize().scale(other_speed));
                            if (!otherPlayer.animation) {
                                otherPlayer.animation = scene.beginAnimation(otherPlayer.mesh.skeleton, 0, 10, true);
                            }
                        } else {
                            if (otherPlayer.animation) {
                                otherPlayer.animation.stop();
                                otherPlayer.animation = null;
                            }
                        }
                    });
                });
            } else {
                clients[clientId].pos = position;
            }
        }

    };

    ilands();
}